---
layout: default
slug: tutorials-program
---
<div class="row">
 <div class="col-md-11" markdown="1">

<div class="row">
<h1>Accepted Tutorials</h1>
</div>
<div class="row">
<h2>DEVS Modelling and Simulation</h2>

<h3>Speakers: Yentl Van Tendeloo and Hans Vangheluwe</h3>

<h3>Abstract </h3>
DEVS is a popular formalism for modelling complex
dynamic systems using a discrete-event abstraction. At this
abstraction level, a timed sequence of pertinent “events” input
to a system (or internal, in the case of timeouts) cause
instantaneous changes to the state of the system. Due to its
rigorous formal definition, and its support for modular composition,
several advantages are achieved: 1) it is an appropriate
formalisms to model (software) architectures with a precise
behavioural description, granting performance analysis, realtime
execution, and interoperation with actual systems; 2) it is
a “simulation assembly language” to which other simulation
languages can be mapped, granting formalism coupling at the
DEVS level; and 3) it is a hierarchical framework for cosimulation
or orchestration of discrete-event simulators. This
tutorial introduces the Classic DEVS formalism in a bottomup
fashion, using a simple traffic light example. The syntax
and operational semantics of Atomic (behavioural) models are
introduced first, after which Coupled (structural) models are
introduced. We continue to actual applications of DEVS, for example in performance analysis of queueing systems. All examples are presented with the tool PythonPDEVS, though
this introduction is equally applicable to other DEVS tools.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Exploring Decision Space using Actor based Simulation - a Model Based Approach</h2>

<h3>Speakers: Vinay Kulkarni, Tony Clark, Souvik Barat and Balbir Barn</h3>

<h3>Abstract</h3>
Large complex systems such as modern enterprises typically exhibit a system of systems character. As a result, it is difficult to have an understanding of the overall system behaviour through decomposition in a top-down manner. Inherent uncertainty and fragmented information further exacerbate the task. Instead, we propose a bottom-up approach wherein the fragmented localized behaviours are captured using Actor abstraction and these micro-behaviours are simulated leading to the emergent macro-behaviour which is then analyzed using pattern-matching techniques. Ramifications of changing micro-behaviours onto the macro-behaviour can be observed using simulation thus providing an aid for exploring decision space of a large complex system. We introduce a new technology that supports decision space exploration using Actor based simulation and illustrate how it is applied to real life problems using real world case studies.
<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Managing the Co-Evolution of Domain-Specific Languages and Models</h2>

<h3>Speakers: Juha-Pekka Tolvanen and Steven Kelly</h3>

<h3>Abstract</h3>
Refinement, enhancement and other maintenance tasks normally account for more work than the initial development phase. This applies to domain-specific languages and models, too. This tutorial describes practices for managing the evolution of domain-specific modelling languages, while co-evolving the models that have already been created. The presented practices are field-tested in industry cases -- some managed and refined over three decades. Participants will learn practices and patterns to form part of their toolbox for evolving their languages while in use alongside models. During the tutorial the practices learned are made concrete by applying them to sample cases.
<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>ThingML: Model-Driven Software Engineering for Heterogeneous and Distributed Reactive Systems</h2>

<h3>Speakers: Franck Fleurey, Brice Morin, Jakob Høgenes and Nicolas Ferry</h3>

<h3>Abstract</h3>
A Cyber Physical Systems (CPS) typically relies on a
highly heterogeneous interconnection of platforms and devices
offering a diversity of complementary capabilities: from cloud
server with their virtually unlimited resources to tiny microcontrollers
supporting the connection to the physical world.
This tutorial presents a tool supported Model-Driven Software
Engineering (MDSE) approach targeting the heterogeneity and
distribution challenges associated with the development of
CPS. The approach is based on a domain specific modelling
languages called ThingML. The foundations and rational of
ThingML have been elaborated over the past years based on a
set of experiences and projects aiming applying the state of the
art in MDSE in practical contexts and with different industry
partners. The aim of the tutorial is (i) to reflect on these
experiences to motivate the approach and its implementation,
(ii) to describe the approach and its usage by the actors
involved in the development of CPS and (iii) to provide handson
experience with the associated tools.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Making Modeling Cool Again: Teaching and Researching Model-Driven Engineering using Animation, 3D Simulation and the Internet of Things</h2>

<h3>Speakers: Juergen Dingel, Karim Jahed and Ernesto Posse</h3>

<h3>Abstract</h3>
The tutorial will provide a short overview of modeldriven
software development (MDSD) with UML-RT and
Papyrus-RT. UML-RT is a proven UML profile for real-time
embedded software supported by several tools including IBM
RSA-RTE, eTrice, and Papyrus-RT, an open-source MDSD
tool. Moreover, the tutorial will show how Unity3D, a popular
development tool for three-dimensional video games, can be
used to animate the executions of code generated from models,
and to define and implement simulation scenarios that the
generated code interacts with. Finally, the tutorial will illustrate
how generated code can leveraged for the development of
Internet of Things (IoT) applications created with development
tools such as Node-RED. In each case, a key ingredient is a
suitable communication mechanism that connects the generated
code with external and separately developed software in a
suitable fashion. A central goal of the tutorial is to demonstrate
how model-driven software development (MDSD) with open
source tooling can be used in concert with software from other
technical domains and how this joint use can be mutually
beneficial by addressing problems in either MDE or the other
domain.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Develop your Own Car</h2>

<h3>Speakers: Levi Lucio, Sebastian Voss, Tatiana Chuprina, Andreas Bayha, Johannes Eder and Sudeep Kanav</h3>

<h3>Abstract</h3>
AUTOFOCUS3(AF3)is a mature model-driven engineering environment to develop software for embedded systems. For the past 20 years,several versions of AF3 have served as a platform for experimenting with cutting-edge research ideas in Model-Driven Development. AF3 is a tool that fully encompasses the software life cycle, from requirements, to architecture, simulation, deployment, code generation and verification. The attendees of this tutorial will be given the unique opportunity to model and deploy software on a real remote-controlled vehicle, using only AF3. Attendees will start by modeling the software controller for a blinker, which will be integrated with the model of the vehicle’s software. The generated code will then be flashed onto a Raspberry Pi contained in the physical remote-controlled model vehicle which can then be driven in the real world. Attendees who finish early will be able to model more advanced driving assistance functionalities. The last
part of the tutorial will be dedicated to deepening the attendees’ understanding of the modeling capabilities of AF3 in areas such as requirements engineering, design-space exploration, building
safety cases, formal verification, modeling processes, testing or variability modeling.

<p>Length: full day</p>

</div>

<hr>

<div class="row">
<h2>RobMoSys: Better Models and Software for Robotic Systems</h2>

<h3>Speakers: Christian Schlegel and Herman Bruyninckx</h3>

<h3>Abstract</h3>
The EU H2020 RobMoSys Project (http://robmosys.eu) aims to
coordinate the whole robotics community’s best and consorted
effort to realize a step change towards a European ecosystem for
open and industry-grade model-driven software development for
robotics.
This tutorial introduces the principles and model-driven
approaches for robotics envisioned in RobMoSys. It explains by
the means of an Eclipse-based tooling how the modeling
principles become accessible to different roles like component
suppliers, system builders, experts for task plots, and others and
how models are being transformed into composable software
artefacts.
A major goal of this tutorial is to give RobMoSys exposition in
the “generic” MDE community and attract more researchers
towards robotics problems. This is also about explicating the
special needs of robotics and discussing these with the MDE
community.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>How to Build Domain Specific Modeling Languages and Interpreters with WebGME – an Online, Collaborative Metamodeling Environment</h2>

<h3>Speakers: Patrik Meijer and Tamas Kecskes</h3>

<h3>Abstract</h3>
WebGME (Generic Modeling Environment) is a
web-based, online, collaborative metamodeling environment
maintained by Vanderbilt University available as open source
under the MIT licence. WebGME supports the design of Domain
Specific Modeling Languages (DSML) and the creation of
corresponding domain models. The main design drivers have
been scalability, extensibility and version control. WebGME
provides a variety of extension points to customize the
application and build up Design Studios suiting articular needs.
These extensions include: plugins/interpreters, decorators,
visualizers, server routers, webhooks, layouts etc. These can be
neatly generated, shared and imported using a command line
interface, webgme-cli. After an initial introduction, the first part
of the tutorial will focus on how to define and construct a
metamodel for a specific domain using the bundled GUI running
inside a browser. As the metamodel progresses a domain model
will be built up in parallel, highlighting the way WebGME fuses
the aspects of metamodeling and modeling. In the second part, a
model interpreter for code generation will be written using an
integrated code editor inside of the WebGME GUI. In the final
part an outline of how a fully customized WebGME Design
Studio can be built up will be presented.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Taming Large Models using Hawk and NeoEMF</h2>

<h3>Speakers: Antonio Garcia-Dominguez, Dimitris Kolovos, Konstantinos Barmpis, Gwendal Daniel and Gerson Sunyé</h3>

<h3>Abstract</h3>
Industrial models can quickly reach a complexity
and size that makes storing them entirely in single files prohibitive.
These larger models are typically either broken up
into smaller files, or stored in a database. Using smaller files
is simpler, but running a global query can still require loading
all the files and therefore run into the same scalability issues. As
for databases, most people go directly for well-known relational
databases. However, a relational database is not the only answer
for scalability: we can use NoSQL databases to solve the issues
with queries over fragmented models, or replace relational model
stores altogether.
In this tutorial, we will discuss two approaches for achieving
scalable model persistence and querying through our Hawk
and NeoEMF open-source tools. Hawk’s approach is to use a
NoSQL database as an efficient index to the models, focusing on
improving query speed while keeping your existing persistence as
is. NeoEMF allows for persisting models in a NoSQL database,
which can speed up loading and writing of the models as well.
The presenters are the original developers of the tools, which
have seen industrial adoption through the MONDO EU FP7 and
ITEA3 MEASURE projects.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Developing Reactive Systems with Statecharts</h2>

<h3>Speakers: Simon Van Mierlo and Hans Vangheluwe</h3>

<h3>Abstract</h3>
Statecharts, introduced by Harel, is used to specify
complex, timed, reactive, autonomous discrete-event systems.
It is an extension of Timed Finite State Automata which adds
depth, orthogonality, broadcast communication and history. Its
visual representation is based on higraphs, which combine
graphs and Venn diagrams. This representation is most
suited to represent Statecharts models, and many tools offer
visual editing and simulation support for the Statecharts formalism.
Examples include STATEMATE, Rhapsody,
Yakindu, and Stateflow.
This tutorial introduces Statecharts modelling, simulation,
and testing. As a running example, the behaviour of a simple
timed, autonomous, reactive system is modelled: a traffic light.
We start from the basic concepts of states and transitions and
explain the more advanced concepts of Statecharts by extending
the example incrementally. We discuss several semantics
options, such as STATEMATE and Rhapsody semantics. We
use Yakindu to model the example system.

<p>Length: half day</p>

</div>

<hr>

<div class="row">
<h2>Seamless Modelbased Systems Engineering: The SPES Approach</h2>

<h3>Speakers: Andreas Vogelsang, Wolfgang Boehm, Sebastian Voss and Ilias Gerostathopoulos</h3>

<h3>Abstract</h3>
Cyber-physical systems are based on networked
embedded software systems, which connect computational entities
in a collaborative manner with physical entities of the real world
to achieve an overall purpose for its users. Together with available
content and services from the Internet, they build networks of
collaborating systems that integrate (monitor, coordinate, control)
with the physical environment. Mastering the engineering of
complex and trustworthy CPS poses serious challenges, which
have to be addressed by the engineering methodologies of the
future. The SPES methodology is a development methodology
for cyber-physical systems, which has been developed for more
than six years by over 20 partners from academia and industry.
Meanwhile, the methodology has been adopted by several
companies in Germany. The core of the SPES methodology is a
modeling framework, which comprises the fundamental modeling
concepts that are needed, including relationships between models
such as refinement, and ways to define mappings between
modeling concepts. The SPES modeling framework categorizes
these artifacts into four viewpoints and allows specifying artifacts
on a dynamic model of layers of abstraction. This tutorial
provides an overview of the SPES modeling framework as well
as hands-on exercises and demos in the tool AutoFocus3.

<p>Length: half day</p>

</div>

<hr>



</div>
</div>


